#!/bin/env python

import subprocess
import time

import htcondor


class Execution(object):

    def __init__(self):

        self.list_attributes = ['ClusterId', 
                                'ProcId', 
                                'Owner', 
                                'QDate', 
                                'Cmd', 
                                'JobStatus', 
                                'EnteredCurrentStatus', 
                                'EC2AmiID', 
                                'MATCH_APF_QUEUE']

    def run(self):

        schedd = htcondor.Schedd()
        out = schedd.query('true', self.list_attributes)
        
        self.jobslist = JobsList()
        
        for job_classad in out:
            new_job = Job(job_classad, self)
            self.jobslist.add(new_job)

    def output(self):
        self.jobslist.sort()

        # FIXME
        # output should not return a string, I think
        return self.jobslist.__str__()



class Job(object):

    def __init__(self, job_classad, execution):
        """
        """
  
        self.jobslist = None
       
        # add a class attribute for each item in list_attributes
        # the name of the class attribute is just the lower case version of the value in list_attributes
        # For example:
        #       self.clusterid = job_classad['ClusterId']
        #       self.procid = job_classad['ProcId'] 
        #       self.owner = job_classad['Owner'] 
        #       self.qdate = job_classad['QDate'] 
        #       self.cmd = job_classad['Cmd'] 
        #       self.jobstatus = job_classad['JobStatus']
        #       self.enteredcurrentstatus = job_classad['EnteredCurrentStatus'] 
        #       self.ec2amiid = job_classad['EC2AmiID'] 
        #       self.match_apf_queue = job_classad['MATCH_APF_QUEUE']
        #
        for att in execution.list_attributes:
            setattr(self, att.lower(), job_classad.get(att, "UNDEFINED"))

        self.id = '%s.%s' %(self.clusterid, self.procid)

        status_mappings = {0: 'U', 
                           1: 'I',
                           2: 'R',
                           3: 'X',
                           4: 'C',
                           5: 'H',
                           6: 'E'}
        self.jobstatus = status_mappings[self.jobstatus]

        if self.jobstatus == 'R':
            self.timecurrentstatus = float(time.time()) - float(self.enteredcurrentstatus)
            self.timecurrentstatus = int(self.timecurrentstatus)
        else:
            self.timecurrentstatus = 0


        self.qdate = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(float(self.qdate)))

        days = self.timecurrentstatus/(24*3600)
        rest = self.timecurrentstatus - days*24*3600
        m, s = divmod(int(rest), 60)
        h, m = divmod(m, 60)
        self.enteredcurrentstatus= '%d+%02d:%02d:%02d' %(days, h, m, s)

    def __cmp__(self, other):
        if self.id < other.id:
            return -1
        elif self.id > other.id:
            return 1
        else:
            return 0

    def __str__(self):

        s = ''
        s += '%s' %self.id
        s += ' '*(self.jobslist.maxid - len(self.id))
        s += '  %s' %self.owner
        s += ' '*(self.jobslist.maxowner -len(self.owner)) 
        s += '  %s' %self.qdate
        s += '  %s' %self.cmd
        s += ' '*(self.jobslist.maxcmd -len(self.cmd)) 
        s += '  %s' %self.jobstatus
        s += '  %s' %self.enteredcurrentstatus
        s += ' '*(self.jobslist.maxtime -len(self.enteredcurrentstatus)) 
        s += '  %s' %self.ec2amiid
        s += ' '*(self.jobslist.maxec2ami -len(self.ec2amiid)) 
        s += '  %s' %self.match_apf_queue
        s += '\n'
        return s


class JobsList(object):

    def __init__(self):

        self.jobs = []

        self.maxid = 0
        self.maxowner = 0        
        self.maxcmd = 0         
        self.maxtime = 0             
        self.maxec2ami = 0

    def add(self, job):

        job.jobslist = self

        self.jobs.append(job)

        if len(job.id)                   > self.maxid     : self.maxid     = len(job.id)
        if len(job.owner)                > self.maxowner  : self.maxowner  = len(job.owner)          
        if len(job.cmd)                  > self.maxcmd    : self.maxcmd    = len(job.cmd)            
        if len(job.enteredcurrentstatus) > self.maxtime   : self.maxtime   = len(job.enteredcurrentstatus)            
        if len(job.ec2amiid)             > self.maxec2ami : self.maxec2ami = len(job.ec2amiid)


    def sort(self):
        self.jobs.sort()


    def __str__(self):

        s = ''
        for job in self.jobs:
            s += job.__str__()

        if len(s)>0:
            s = s[:-1]
  
        return s

if __name__ == '__main__':

    exe = Execution()
    exe.run()
    print exe.output()


