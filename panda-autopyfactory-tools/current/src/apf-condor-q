#!/bin/env python

import subprocess
import time

import htcondor
import classad



class Execution(object):

    def __init__(self):

        self.list_attributes = ['ClusterId', 
                                'ProcId', 
                                'Owner', 
                                'QDate', 
                                'Cmd', 
                                'JobStatus', 
                                'EnteredCurrentStatus', 
                                'EC2AmiID', 
                                'MATCH_APF_QUEUE']

    def run(self):

        schedd = htcondor.Schedd()
        out = schedd.query('true', self.list_attributes)
        
        self.jobslist = JobsList(['id', 'owner', 'cmd', 'enteredcurrentstatus', 'ec2amiid'])
        
        for job_classad in out:
            new_job = Job(job_classad, self)
            self.jobslist.add(new_job)

    def output(self):
        self.jobslist.sort()

        # FIXME
        # output should not return a string, I think
        return self.jobslist.__str__()



class Job(object):

    def __init__(self, job_classad, execution):
        """
        """
  
        self.jobslist = []
       
        # add a class attribute for each item in list_attributes
        # the name of the class attribute is just the lower case version of the value in list_attributes
        # For example:
        #       self.clusterid = job_classad['ClusterId']
        #       self.procid = job_classad['ProcId'] 
        #       self.owner = job_classad['Owner'] 
        #       self.qdate = job_classad['QDate'] 
        #       self.cmd = job_classad['Cmd'] 
        #       self.jobstatus = job_classad['JobStatus']
        #       self.enteredcurrentstatus = job_classad['EnteredCurrentStatus'] 
        #       self.ec2amiid = job_classad['EC2AmiID'] 
        #       self.match_apf_queue = job_classad['MATCH_APF_QUEUE']
        # This can be done also with a dictionary,
        # like self.dict_attr[ key ] = value
        # but then the rest of the code is filled with stuff like
        #    self.dict_attr[key] 
        # instead of
        #    self.key
        # Using class attributes seems to be a little bit cleaner
        #
        for att in execution.list_attributes:
            setattr(self, att.lower(), job_classad.get(att, "undefined" ))

        self.id = '%s.%s' %(self.clusterid, self.procid)

        status_mappings = {0: 'U', 
                           1: 'I',
                           2: 'R',
                           3: 'X',
                           4: 'C',
                           5: 'H',
                           6: 'E'}
        self.jobstatus = status_mappings[self.jobstatus]

        if self.jobstatus == 'R':
            self.timecurrentstatus = float(time.time()) - float(self.enteredcurrentstatus)
            self.timecurrentstatus = int(self.timecurrentstatus)
        else:
            self.timecurrentstatus = 0


        self.qdate = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(float(self.qdate)))

        days = self.timecurrentstatus/(24*3600)
        rest = self.timecurrentstatus - days*24*3600
        m, s = divmod(int(rest), 60)
        h, m = divmod(m, 60)
        self.enteredcurrentstatus= '%d+%02d:%02d:%02d' %(days, h, m, s)

    def __cmp__(self, other):
        if self.id < other.id:
            return -1
        elif self.id > other.id:
            return 1
        else:
            return 0

    def __str__(self):

        s = ''
        s += '%s' %self.id
        s += ' '*(self.jobslist.max_len_attr['id'] - len(self.id))
        s += '  %s' %self.owner
        s += ' '*(self.jobslist.max_len_attr['owner'] - len(self.owner)) 
        s += '  %s' %self.qdate
        s += '  %s' %self.cmd
        s += ' '*(self.jobslist.max_len_attr['cmd'] -len(self.cmd)) 
        s += '  %s' %self.jobstatus
        s += '  %s' %self.enteredcurrentstatus
        s += ' '*(self.jobslist.max_len_attr['enteredcurrentstatus'] -len(self.enteredcurrentstatus)) 
        s += '  %s' %self.ec2amiid
        s += ' '*(self.jobslist.max_len_attr['ec2amiid'] -len(self.ec2amiid)) 
        s += '  %s' %self.match_apf_queue
        s += '\n'

        return s


class JobsList(object):
    """
    This class is just a container of objects.
    It is actually a completely abstract class
    so it can handle any kind of objects

    It maintains a list of objects

    Each time a new object is added to the list, 
    via method add( ),
    the string length of several object attributes
    is checked, and the current maximum length is 
    stored in a dictionary self.max_len_attr

    The exact list of object attributes whose lengths
    must be tracked is passed to the __init__( ) as input

    There is a sort( ) method.
    Therefore, the objects this container is handling
    are expected to have a method __cmp__( ) implemented

    There is a method __str__( ) that calls the
    corresponding __str__( ) for the objects being stored.
    So the objects must implement this __str__( ) method
    """

    def __init__(self, list_attr):

        self.jobs = []

        self.max_len_attr = {}
        for i in list_attr:
            self.max_len_attr[i] = 0


    def add(self, job):

        job.jobslist = self

        self.jobs.append(job)

        for k in self.max_len_attr.keys():
           v = getattr(job, k)
           job_attr_len = len(getattr(job, k))
           if job_attr_len > self.max_len_attr[k]:
               self.max_len_attr[k] = job_attr_len 
               

    def sort(self):
        self.jobs.sort()


    def __str__(self):

        s = ''
        for job in self.jobs:
            s += job.__str__()

        if len(s)>0:
            # this is to remove the very last \n
            s = s[:-1]
  
        return s



if __name__ == '__main__':

    exe = Execution()
    exe.run()
    print exe.output()

