#!/bin/env python

import subprocess
import time

import htcondor



class Execution(object):

    def __init__(self):

        # this is the list of HTCondor Job's ClassAds to query 
        self.query_attributes = ['ClusterId', 
                                'ProcId', 
                                'Owner', 
                                'QDate', 
                                'Cmd', 
                                'JobStatus', 
                                'EnteredCurrentStatus', 
                                'EC2AmiID', 
                                'MATCH_APF_QUEUE']

        # this is the list of attributes, or fields,  
        # we want to display in the output
        self.output_attributes = ['id', 
                                  'owner', 
                                  'qdate', 
                                  'cmd', 
                                  'jobstatus', 
                                  'enteredcurrentstatus', 
                                  'ec2amiid', 
                                  'match_apf_queue']

        self.container = Container(self.output_attributes)


    def run(self):

        self._query()
        self._store()


    def _query(self):

        schedd = htcondor.Schedd()
        self.out = schedd.query('true', self.query_attributes)


    def _store(self):
        
        for job_classad in self.out:
            new_job = Job(job_classad, self)
            self.container.add(new_job)


    def get(self):
        self.container.sort()
        return self.container.get()


class UI(object):

    def display(self):

    out = self.get()

        if len(out) == 0:
            return ""
        
        # if there is actual content in out...
        maxs = []
        for i in range(len(out[0])):
            maxs.append(len(max(out[j][i] for j in range(len(out)))))

        for line in out:
            s = ""
            for i in range(len(line)):
                s += "%s  " %line[i]
                s += " " * (maxs[i] - len(line[i]) )
            print s



class Job(object):

    def __init__(self, job_classad, execution):
        """
        job_classad is each one of the objects returned by htcondor.Schedd().query() method
        execution is a "pointer" to the class Execution that creates all Job() objects
        """
  
        self.container = None
       
        # add a class attribute for each item in list_attributes
        # the name of the class attribute is just the lower case version of the value in list_attributes
        # For example:
        #       self.clusterid = job_classad['ClusterId']
        #       self.procid = job_classad['ProcId'] 
        #       self.owner = job_classad['Owner'] 
        #       self.qdate = job_classad['QDate'] 
        #       self.cmd = job_classad['Cmd'] 
        #       self.jobstatus = job_classad['JobStatus']
        #       self.enteredcurrentstatus = job_classad['EnteredCurrentStatus'] 
        #       self.ec2amiid = job_classad['EC2AmiID'] 
        #       self.match_apf_queue = job_classad['MATCH_APF_QUEUE']
        # This can be done also with a dictionary,
        # like self.dict_attr[ key ] = value
        # but then the rest of the code is filled with stuff like
        #    self.dict_attr[key] 
        # instead of
        #    self.key
        # Using class attributes seems to be a little bit cleaner
        #
        for att in execution.query_attributes:
            setattr(self, att.lower(), job_classad.get(att, "undefined" ))

        self._parseattributes()

    
    def _parseattributes(self):
        """
        in this method we manipulate the content 
        of the job_classad input variables
        to build the final output with the format we want
        """

        self.id = '%s.%s' %(self.clusterid, self.procid)

        status_mappings = {0: 'U', 
                           1: 'I',
                           2: 'R',
                           3: 'X',
                           4: 'C',
                           5: 'H',
                           6: 'E'}
        self.jobstatus = status_mappings[self.jobstatus]

        if self.jobstatus == 'R':
            self.timecurrentstatus = float(time.time()) - float(self.enteredcurrentstatus)
            self.timecurrentstatus = int(self.timecurrentstatus)
        else:
            self.timecurrentstatus = 0


        self.qdate = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(float(self.qdate)))

        days = self.timecurrentstatus/(24*3600)
        rest = self.timecurrentstatus - days*24*3600
        m, s = divmod(int(rest), 60)
        h, m = divmod(m, 60)
        self.enteredcurrentstatus= '%d+%02d:%02d:%02d' %(days, h, m, s)


    def __cmp__(self, other):
        """
        to sort all jobs by id number
        """

        if self.id < other.id:
            return -1
        elif self.id > other.id:
            return 1
        else:
            return 0

    def get(self):
        #print [getattr(self,att) for att in self.container.list_attr]
        return [getattr(self,att) for att in self.container.list_attr]
        

    def __str__(self):
        """
        we build the final output string
        by looping over all items in Execution.output_attributes
        ( which is the same that self.container.list_attr )

        For each item, we
           1) add the item to the string
           2) as many white spaces as needed to align columns
       
        The needed number of white spaces is calculated from 
        the difference of current item length and maximum item length.
        The maximum item length is stored in 
        self.container.max_len_attr dictionary.
        """

        s = ''
        for attr in self.container.list_attr:
            s += '%s  ' %getattr(self, attr)
            s += ' '* (self.container.max_len_attr[attr] - len(getattr(self, attr)))
        s += '\n'

        return s


class Container(object):
    """
    This class is just a container of objects.
    It is actually a completely abstract class
    so it can handle any kind of objects

    It maintains a list of objects

    Each time a new object is added to the list, 
    via method add( ),
    the string length of several object attributes
    is checked, and the current maximum length is 
    stored in a dictionary self.max_len_attr

    The exact list of object attributes whose lengths
    must be tracked is passed to the __init__( ) as input

    There is a sort( ) method.
    Therefore, the objects this container is handling
    are expected to have a method __cmp__( ) implemented

    There is a method __str__( ) that calls the
    corresponding __str__( ) for the objects being stored.
    So the objects must implement this __str__( ) method
    """

    def __init__(self, list_attr):

        self.list_attr = list_attr

        self.objs = []

        self.max_len_attr = {}
        for i in list_attr:
            self.max_len_attr[i] = 0


    def add(self, obj):

        obj.container = self
        self.objs.append(obj)


    def sort(self):
        self.objs.sort()


    def get(self):
        out = []
        for obj in self.objs:
           out.append(obj.get())
        return out

    def __str__(self):

        s = ''
        for obj in self.objs:
            s += obj.__str__()

        if len(s)>0:
            # this is to remove the very last \n
            s = s[:-1]
  
        return s


class MyClass(Execution, UI):
    pass

if __name__ == '__main__':

    exe = MyClass()
    exe.run()
    exe.display()


