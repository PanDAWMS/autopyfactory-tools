#!/bin/env python

import subprocess
import time

import htcondor



class Query(object):
    """
    This is the class that implements the HTCondor query.
    It just does that, it does not interpret the output of the query,
    for each line in the output, it creates an object of class Job() 
    and feed it with that line. 
    The object Job( ) is supposed to know how to interpret and manipulate
    the content of the output of the HTCondor query.
    """

    def __init__(self):

        # this is the list of HTCondor Job's ClassAds to query 
        self.query_attributes = ['ClusterId', 
                                'ProcId', 
                                'Owner', 
                                'QDate', 
                                'Cmd', 
                                'JobStatus', 
                                'EnteredCurrentStatus', 
                                'EC2AmiID', 
                                'MATCH_APF_QUEUE']

        self.container = Container()

    def run(self):

        self._query()
        self._store()


    def _query(self):

        schedd = htcondor.Schedd()
        self.out = schedd.query('true', self.query_attributes)


    def _store(self):
        
        for job_classad in self.out:
            new_job = Job(job_classad, self)
            self.container.add(new_job)


    def get(self):
        self.container.sort()
        return self.container.get()


class UI(object):
    """
    this class just implements a method to print out to the stdout 
    the final results

    It simply gets the output of the query, after being interpreted and 
    manipulated, by calling method get( )
    This class does not implement method get( ), 
    so get( ) it is supposed to be implemented in a different class XYZ,
    and everything being used by a child class:

        class Child(XYZ, UI)

    therefore, class Child will have available methods from this class UI
    and from class XYZ that implements get( ), among other things.
    """

    def display(self):
        """
        this is the method that prints out to stdout the results
        of the query.

        We first call get( ), which is implemented in a different class.
        The output of get MUST be a list of lists.
        We calculate, the maximum lenght for each field 
        -in other words, each item at position i for each list-.
        Then we just double loop over the list of lists, 
        print each field, and the needed number of white spaces to 
        reach the maximum previously calculated for that field.
        That way, all fields are always displayed well aligned. 
        """

    out = self.get()

        if len(out) == 0:
            return ""
        
        # if there is actual content in out...
        maxs = self._calculate_max(out)
        self._display(out, maxs)
 

    def _calculate_max(self, out):

        maxs = []
        for i in range(len(out[0])):
            # max length for field i on every line in out:
            max_i = max(len(obj[i]) for obj in out)
            maxs.append(max_i)
        return maxs


    def _display(self, out, maxs):

        for line in out:
            s = ""
            for i in range(len(line)):
                s += "%s  " %line[i]
                s += " " * (maxs[i] - len(line[i]) )
            print s


class Job(object):
    """
    This is the class to handle each Job.
    Therefore, this is the class that knows how to interpret and manipulate
    the output of the query done in class Query( )
    """

    def __init__(self, job_classad, query):
        """
        job_classad is each one of the objects returned by htcondor.Schedd().query() method
        query is a "pointer" to the class Query that creates all Job() objects
    We use a reference to Query( ) class 
        because it contains a list of the classad attributes
        being used in the query, 
        which is the list of attributes in the job_classad input variable,
        so we know what is each field in job_classad
        """

        self.query = query
        self.job_classad = job_classad

        # this is the list of attributes, or fields,  
        # we want to display in the output
        self.list_attr = ['id', 
                          'owner', 
                          'qdate', 
                          'cmd', 
                          'jobstatus', 
                          'enteredcurrentstatus', 
                          'ec2amiid', 
                          'match_apf_queue']
  
        self._create_attributes()
        self._parseattributes()


    def _create_attributes(self):
        """ 
        add a class attribute for each item in list_attributes
        the name of the class attribute is just the lower case version of the value in list_attributes
        For example:

              self.clusterid = self.job_classad['ClusterId']
              self.procid = self.job_classad['ProcId'] 
              self.owner = self.job_classad['Owner'] 
              self.qdate = self.job_classad['QDate'] 
              self.cmd = self.job_classad['Cmd'] 
              self.jobstatus = self.job_classad['JobStatus']
              self.enteredcurrentstatus = self.job_classad['EnteredCurrentStatus'] 
              self.ec2amiid = self.job_classad['EC2AmiID'] 
              self.match_apf_queue = self.job_classad['MATCH_APF_QUEUE']
              ...

        This can be done also with a dictionary,
        like self.dict_attr[ key ] = value
        but then the rest of the code is filled with stuff like
 
           self.dict_attr[key] 

        instead of

           self.key

        Using class attributes seems to be a little bit cleaner.
        That is the only reason to do it this way.

        If some of the fields was not included in the query output,
        we give string "undefined" to it. 
        We do that, because we want all fields always to have a content,
        so when they are displayed, all columns exists.
        """ 
        
        for att in self.query.query_attributes:
            setattr(self, att.lower(), self.job_classad.get(att, "undefined" ))

    
    def _parseattributes(self):
        """
        in this method we manipulate the content 
        of the job_classad input variables
        to build the final output with the format we want
        """

        self.id = '%s.%s' %(self.clusterid, self.procid)

        status_mappings = {0: 'U', 
                           1: 'I',
                           2: 'R',
                           3: 'X',
                           4: 'C',
                           5: 'H',
                           6: 'E'}
        self.jobstatus = status_mappings[self.jobstatus]

        if self.jobstatus == 'R':
            self.timecurrentstatus = float(time.time()) - float(self.enteredcurrentstatus)
            self.timecurrentstatus = int(self.timecurrentstatus)
        else:
            self.timecurrentstatus = 0


        self.qdate = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(float(self.qdate)))

        days = self.timecurrentstatus/(24*3600)
        rest = self.timecurrentstatus - days*24*3600
        m, s = divmod(int(rest), 60)
        h, m = divmod(m, 60)
        self.enteredcurrentstatus= '%d+%02d:%02d:%02d' %(days, h, m, s)


    def __cmp__(self, other):
        """
        to sort all jobs by id number
        """

        if self.id < other.id:
            return -1
        elif self.id > other.id:
            return 1
        else:
            return 0


    def get(self):
        return [getattr(self,att) for att in self.list_attr]
        

    ###def __str__(self):
    ###    """
    ###    we build the final output string
    ###    by looping over all items in self.list_attr
    ###    For each item, we
    ###       1) add the item to the string
    ###       2) as many white spaces as needed to align columns
    ###   
    ###    The needed number of white spaces is calculated from 
    ###    the difference of current item length and maximum item length.
    ###    The maximum item length is stored in 
    ###    self.container.max_len_attr dictionary.
    ###    """
    ###    s = ''
    ###    for attr in self.list_attr:
    ###        s += '%s  ' %getattr(self, attr)
    ###        s += ' '* (self.container.max_len_attr[attr] - len(getattr(self, attr)))
    ###    s += '\n'
    ###    return s


class Container(object):
    """
    This class is just a container of objects.
    It is actually a completely abstract class
    so it can handle any kind of objects.
    """

    def __init__(self):

        self.objs = []


    def add(self, obj):

        obj.container = self
        self.objs.append(obj)


    def sort(self):
        """
        For this method to work, 
        the objects being stored are expected
        to have a method __cmp__( ) implemented
        """
        self.objs.sort()


    def get(self):
        out = []
        for obj in self.objs:
           out.append(obj.get())
        return out

    ###def __str__(self):
    ###    s = ''
    ###    for obj in self.objs:
    ###        s += obj.__str__()
    ###    if len(s)>0:
    ###        # this is to remove the very last \n
    ###        s = s[:-1]
    ###    return s


class QueryUI(Query, UI):
    """
    this class just put together
    the class Query( ), which runs the queries
    and manage the output, 
    and class UI( ), which knows how to print out
    that content to the stdout
    """
    pass
    # FIXME ??? do I need to do something here ???


if __name__ == '__main__':

    queryui = QueryUI()
    queryui.run()
    queryui.display()


